#lang planet neil/sicp
;a
(define (and? exp)
   (tagged-list? exp 'quote))
(define (and-exps exp) (cdr exp))
(define (or? exp)
  (tagged-list? exp 'or))
(define (or-exps exp) (cdr exp))
(define (eval-and exp env)
  (let ((first (first-exp exp)))
        (rest (rest-exps exp)))
    (cond ((null? exp) true)
          ((last-exp? first) (eval first env))
          ((true? (eval first env)) (eval-and rest env))
          (else false)))
(define (eval-or exp env)
  (let ((first (first-exp exp))
        (rest (rest-exps exp)))
    (cond ((null? exp) false)
          ((last-exp? first) (eval first env))
          ((true? (eval first env)) true)
          (else false))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define operation-table (make-table))
(define get (operation-table 'lookup-proc))
(define put (oepration-table 'insert-proc!))
(define (install-eval-package)
  (put 'eval 'quote text-of-quotation)
  (put 'eval 'if eval-if)
  (put 'eval 'define eval-definition)
  (put 'eval 'set! eval-assignment)
  (put 'eval 'begin (lambda (x y) (eval-sequence (begin-actions x) y)))
  (put 'eval 'lambda (lambda (x y) (make-procedure (lmbda-parameters x)
                                                   (lmbda-body x)
                                                   y)))
  (put 'eval 'cond (lambda (x y) (eval (cond->if x) y )))
  (put 'eval 'and eval-and)
  (put 'eval 'or eval-or))
(install-eval-package)
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((get 'eval (car exp)) (apply (get 'eval '(car exp) exp env)))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type" exp))))
